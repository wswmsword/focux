# 原理

- 找到元素的方向元素；
- 按需计算；
  - 拼接下一页；
  - 丢弃上一页；
- 嵌套，重新计算嵌套内元素（如轮播）；
- 吸附区优化，必须导航；
- 路径记忆。



1. 找到 wrap
2. 找到 wrap 的方向元素 wrap2
3. 找到 wrap2 内的元素
  1. 首个 loc 元素
  2. 首次定位找到位置元素，后续通过记忆



嵌套、同级。

- 所有的 subs 都需要 wrap
- 最外层，只有在有兄弟时，需要 wrap

simple:

```json
[
  [4, 3, 2, 1],
  { "id": "x", "loc": [1, 2, 3, 4] }
]
```

output:

```json
[{
  "locs": [{
    "id": [4, 3, 2, 1],
    "loc": [4, 3, 2, 1]
  }, {
    "id": "x",
    "loc": [1, 2, 3, 4]
  }]
}]
```

obj:

```json
{
  "locs": [[1, 2, 3, 4], [3, 2, 1, 4]],
  "subs": [{
    "locs": [[1, 2, 3, 4], { "id": "z", "loc": [3, 3, 3, 3] }],
    "wrap": {
      "id": "x",
      "loc": [4, 4, 4, 4]
    },
    "subs": {
        "locs": [[6, 6, 6, 6], [7 ,7 ,7 ,7]],
        "wrap": [9, 9, 9, 9]
    }
  }, {
    "locs": [[2, 2, 2, 2], [1, 1, 1, 1]],
    "wrap": {
      "id": "y",
      "loc": [2, 2, 2, 2]
    },
  }]
}
```

output:

```json
[{
  "locs": [{
    "id": [1, 2, 3, 4],
    "loc": [1, 2, 3, 4]
  }, {
    "id": [3, 2, 1, 4],
    "loc": [3, 2, 1, 4]
  }],
  "subs": [{
    "locs": [{
      "id": [1, 2, 3, 4],
      "loc": [1, 2, 3, 4]
    }, {
      "id": "z",
      "loc": [3, 3, 3, 3]
    }],
    "wrap": {
      "id": "x",
      "loc": [4, 4, 4, 4]
    },
    "subs": [{
      "locs": [
        {
          "id": [6, 6, 6, 6],
          "loc": [6, 6, 6, 6]
        }, {
          "id": [7, 7, 7, 7],
          "loc": [7, 7, 7, 7]
        }
      ],
      "wrap": {
        "loc": [9, 9, 9, 9],
        "id": [9, 9, 9, 9]
      }
    }]
  }, {
    "locs": [{
      "id": [2, 2, 2, 2],
      "loc": [2, 2, 2, 2]
    }, {
      "id": [1, 1, 1, 1],
      "loc": [1, 1, 1, 1]
    }],
    "wrap": {
      "id": "y",
      "loc": [2, 2, 2, 2]
    }
  }]
}]
```

array:

```json
[{
  "locs": [],
  "wrap": {
    "id": "x",
    "loc": []
  }
}, {
  "locs": [],
  "wrap": {
    "id": "y",
    "loc": []
  }
}]
```